#sort快速排序
在C++中，`std::is_sorted` 是一个C++17标准引入的算法，用于检查一个序列是否是递增排序的。如果序列是严格递增的，即每个元素都不大于其前一个元素，那么`std::is_sorted`将返回`true`。如果序列中存在任何元素大于其前一个元素，则返回`false`。
此外，`std::is_sorted`也有一个变体`std::is_sorted_until`，它返回一个迭代器，指向序列中第一个不满足排序条件的元素。
`std::sort` 是一个用于对序列进行排序的算法，它定义在头文件 `<algorithm>` 中。`std::sort` 可以对数组或任何支持随机访问迭代器的容器进行排序。
### 自定义比较函数
```cpp
`std::sort` 允许传递一个自定义的比较函数，以实现不同的排序逻辑。例如，如果你想要降序排序，可以传递 `std::greater<int>()` 作为比较函数：

	std::sort(v.begin(), v.end(), std::greater<int>());

执行后，`v` 将被排序为 `{5, 4, 3, 2, 1}`。

```
### 使用 #lambda 表达式

C++11 引入了 lambda 表达式，这允许在调用 `std::sort` 时直接定义排序逻辑：

```cpp
std::sort(v.begin(), v.end(), [](int a, int b) {     return a > b; // 降序排序 });
	//对sort进行宏定义 自定义排序逻辑
```

```cpp
	Lambda表达式的一般形式是：
[capture](parameters) mutable -> return_type { body }
```

- **capture**：捕获列表，定义了lambda表达式可以访问的外部变量。
- **parameters**：参数列表，定义了lambda表达式接受的参数。
- **mutable**：可选关键字，允许lambda表达式修改捕获的变量。
- **return_type**：返回类型，定义了lambda表达式的返回类型。
- **body**：函数体，包含lambda表达式的代码。

	使用Lambda表达式进行排序
假设我们有一个`std::vector<int>`，我们想根据元素的绝对值进行排序。下面是如何使用lambda表达式与`std::sort`一起使用的例子：
```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 包含 std::sort

int main() {
    std::vector<int> numbers = {-3, 1, -2, 4, -5, 6};

    // 使用lambda表达式进行排序
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return std::abs(a) < std::abs(b);
    });

    // 打印排序后的数组
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
# 二分
对于能否二分，有一个界定标准：**状态的决策过程或者序列是否满足单调性或者可以局部舍弃性。**
mid = l + r >> 1
mid=L+(r - L)/2是一种防止l+r溢出整数范围的一种写法，数学上等价( L+r ) / 2


# **拓扑排序（topo sort）**
> 例题： https://www.luogu.com.cn/problem/solution/P1113
> 我们在计算的时候，应该确保**在计算一个结点 u 时，所有与连向它的点都已经被计算过**。
#### 总结一下，此种拓扑排序共有四个主要步骤：

1. **初始化队列，将入度为 00 的节点放入队列。**
2. **取出队首，遍历其出边，将能够到达的点入度减一，同时维护答案数组。**
3. **若在此时一个点的入度变为 11，那么将其加入队列。**
4. **回到第二步，直到队列为空。**