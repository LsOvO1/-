动态规划的两个前提首要条件， ==最优化原理==、==无后效性==。

`最优化原理`指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足`最优化原理`，就称其具有`最优子结构性质`。
`无后效性`指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。
# 目录
    背包问题
    线性DP
    区间DP
    计数类DP
    数位统计DP
    状态压缩DP
    树形DP
    记忆化搜索
## [背包问题](https://www.cnblogs.com/fengziwei/p/7750849.html)
> 顾名思义，背包问题泛指给定一组有固定价值和固定重量的物品，以及一个已知最大承重量的背包，求在不超过背包最大承重量的前提下，能放进背包里面的物品的最大总价值。

### 0-1背包
> 0-1背包问题是指每一种物品都只有一件，可以选择放或者不放。现在假设有n件物品，背包承重为m。
```cpp	
#include <bits/stdc++.h>
#define V 500

using namespace std;

int weight[20 + 1];

int value[20 + 1];

int f[20 + 1][V + 1];

int main() {

    int n, m; 
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> weight[i] >> value[i];
    }
    cin >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (weight[i] > j){
                f[i][j] = f[i - 1][j];
            }
            else{
				f[i][j] = f[i - 1][j] > f[i - 1][j - weight[i]] + value[i] ? f[i - 1][j] : f[i - 1][j - weight[i]] + value[i];
            }
        }
    }    
    cout << f[n][m] << endl;
}
```

### 完全背包
### 多重背包