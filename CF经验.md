对于从 l 到 r 的整数数列，==奇数==的数量可以通过以下公式计算
`ans = (r + 1) / 2 - l / 2;`

```cpp
最值问题：
int x = *std::max_element(a.begin(), a.end()); 
对于寻找数组最大元素的操作优化 比sort简洁


循环输出结尾加回车
cout << x << " \n"[m == 0];  
在输出的元素后面增加[] 为条件输出 当满足条件时输出前者


accumulate的用法
// 计算和
int sum = std::accumulate(v.begin(), v.end(), 0);
ll ans = accumulate(a.begin(), a.end(), 0LL)

 // 计算乘积
int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());


```

DIV 3 的 1 ， 2 题 或者DIV2 的 1题通常推导数学公式就能做出 不会就在纸上面先推导数学公式结论。
https://codeforces.com/contest/2014/problem/B 遇到类似读懂了题目但无法转换成代码的题目可以在纸上写出公式直接暴力加减 易推导出 总叶子数-掉叶子数的公式 拆解即可得答案。
$ans =  k * (n - k + 1 + n) / 2;$ 首项加尾项*项数和  奇偶性不会随平方次方改变

回文子序列的数量至少为 $A=2^{a_0}+2^{a_1}⋯+2^{a_4}−5$ (由相同字母组成的每个子序列减去五个空字符串)

测试用例要求为多少就加5 不要开大数组 容易爆

想到用二分答案来解答问题 一般是判断这个题是不是要找一个数组最大值的最小可能 例如：使得整个部队的伤害值最小 https://www.luogu.com.cn/problem/P1902 在这个问题当中我们可以发现整个部队就是最大值 伤害值最小就是最小可能 易判断出此题的求法与二分答案有关 接下来思考check函数的判断条件和check值 可以发现每次check函数只需判断能否从第一行走到最后一行即可，因为每一行的每个门都是相连的，所以只要有一个能到，那么我们再派m-1个人顺着这条路过去再沿着横向的门过去就好啦，因为第一行和最后一行的伤害值为零，所以这么做莫得问题。