> 对于求偶数奇数     i / 2 % 2 会比 i % 2 好 效率更高
> ^ 按位异或运算符  两个数在二进制情况下相同则1 不同则2\
> 条件运算符:`" \n"[i == 0]`：这是一个条件运算符（也称为三元运算符），它检查 `i` 是否等于0。如果 `i` 等于0，它会返回 `" \n"`（一个空格和一个换行符），否则返回空字符串。

# map
[==map的基础用法 把一种定义转换成另一种定义，一般用于计数等==]
虎哥发的：
https://www.yuque.com/u33848042/dn48g9/meuzyq91u097d8so#sIQCE
- map（映射）是C++标准库中的关联容器之一，它提供了键-值对的存储和访问功能。
- 内部使用红黑树实现，可以保持键的有序性。
- 插入、查找、删除操作的平均时间复杂度为O(logN)，其中N是元素数量。
- 元素按照键的升序进行遍历。
- 使用比较函数或运算符来确定元素的顺序。
- 需要额外的空间来维护红黑树的结构。
- 适用于需要有序访问和元素顺序要求的场景。
```cpp
void solve() {

    string s; cin >> s;

    map<char, int> cnt;

    for (auto u : s) {

        cnt[u]++;

    }

    if (cnt['A'] > cnt['B']) {

        cout << "A";

    }

    else cout << "B";

    cout << "\n";

}
```

# 快速读入
对于数字读取优化，**不支持前导零**，**不支持小数**，**不支持空格和换行符**，**不支持其他字符**。
```cpp
inline int read()    //  快速读入

{

    int x=0,f=1;char ch=getchar();

    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}

    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}

    return x*f;

}
```
# 快速输入
```cpp
inline void write(New x) //快速输出
{
	if(x == 0)
	{
		putchar('0');
		return;
	}
	New tmp = x > 0 ? x : -x;
	int cnt = 0;
	if(x < 0)
		putchar( '-' );
	while(tmp > 0)
	{
		F[cnt++] = tmp % 10 + '0';
		tmp /= 10;
	}
	while(cnt > 0)
		putchar(F[--cnt]) ;
}
```
# auto&&的各种用法
**范围基的 for 循环 (auto&&)**: 在 C++11 及以后的版本中，`auto&&` 被称为 "dash" 因为它在类型推导时会 "decay"（退化）掉所有的引用和 const 限定符。这种写法通常用于遍历容器时，当你不想绑定到容器元素的引用，而是希望获得它们的临时对象时
```cpp
for (int i = 0; i < n; i++) {

            c[i] = b[m &mdash; n + i];

            s += abs(c[i] &mdash; a[i]);

        }
```
# pair
- pair 是 C++ 标准库中的类模板，用于表示一个有序的键值对。它通过将两个值组合在一起，形成一个元素。
- 它允许你存储一对值，这两个值可以是相同类型或者不同类型。`std::pair`通常用于存储两个相关联的数据项，例如，你可能需要存储一个值及其索引，或者一个点的坐标（x, y）等。
```cpp
### **==基本用法==**

创建一个`std::pair`对象非常简单，你只需要指定两个值即可：

`#include <utility> // 包含pair的定义 
std::pair<int, std::string> p1(1, "one");`

### 访问元素

你可以通过`.first`和`.second`成员来访问`pair`中的元素：

`int firstValue = p1.first; // 获取first元素的值 
std::string secondValue = p1.second; // 获取second元素的值

### 修改元素

`p1.first = 2; // 修改first元素的值 
p1.second = "two"; // 修改second元素的值

### 使用make_pair


`auto p2 = std::make_pair(3, "three");   //  ~~基本用法类似于auto自动识别~~


### 遍历pair容器

`std::vector<std::pair<int, std::string>> vec = {{1, "one"}, {2, "two"}, {3, "three"}}; 
for (const auto& p : vec) {     
	std::cout << p.first << ": " << p.second << std::endl; 
}`

### pair的比较
	 //首先比较`first`元素，如果相等，则比较`second`元素。

std::pair<int, std::string> p3(1, "uno"); 
std::pair<int, std::string> p4(1, "one"); 
// p3 和 p4 的 first 成员相等，但 second 成员不同 
if (p3 < p4) {     
	std::cout << "p3 is less than p4" << std::endl; 
}

### pair的排序

std::vector<std::pair<int, std::string>> vec = {{3, "three"}, {1, "one"}, {2, "two"}}; 
std::sort(vec.begin(), vec.end());
```
# &的用法
在C++中，表达式 `cnt & 1` 通常用于判断一个整数 `cnt` 是否为奇数。这是通过利用二进制位操作中的按位与（bitwise AND）操作来实现的。
```cpp
if (arr[i] & 1)
            cout << arr[i] << " 是奇数" << endl;
        else
            cout << arr[i] << " 是偶数" << endl;
```
# inline的用法和作用
**函数调用开销**
**编译器优化**
**代码大小和缓存效率**
**链接时优化（LTO)**
`inline`关键字用于建议编译器对函数进行内联展开，以减少函数调用的开销。内联函数的主要目的是优化程序性能，通过避免函数调用时的一些额外开销（如参数传递、栈帧创建和销毁等），来提高程序的执行效率。
# 素数筛
素数，除了1和自己本身不被整除。
```cpp
bool is_prime(int n){
	if(n == 1) return false;
	for(int i = 2; i * i <= n; i++){
		if(n % i == 0) return false;
	}
	return true;
}
```
